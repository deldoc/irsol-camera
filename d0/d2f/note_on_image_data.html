<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>IRSOL: Image Data format</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="../../irsol_logo.jpeg"/></td>
  <td id="projectalign">
   <div id="projectname">IRSOL
   </div>
   <div id="projectbrief">C++ code implementing socket server for interacting with Baumer camera.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('d0/d2f/note_on_image_data.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">Image Data format</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>Overview</h1>
<p>The IRSOL server transmits image data to clients using a custom binary protocol designed for efficiency and compatibility with scientific image processing tools (e.g., OpenCV). This protocol is implemented in the server's <a class="el" href="../../d1/d6f/classirsol_1_1protocol_1_1Serializer.html">irsol::protocol::Serializer</a> and is used whenever an <a class="el" href="../../de/dca/group__Protocol.html#ga92289652b6bf51da04bb8973e7dd5418">irsol::protocol::ImageBinaryData</a> message is sent.</p>
<p>This document describes:</p>
<ul>
<li>The structure of the data sent over the socket for an image.</li>
<li>The meaning and purpose of special bytes and headers.</li>
<li>The byte order and format of the pixel data (including byte-swapping).</li>
<li>An example of the actual data sent.</li>
<li>Pseudocode for robust client-side parsing and decoding.</li>
</ul>
<h1>Protocol Structure</h1>
<p>When the server sends an image to the client, the data is structured as follows:</p>
<div class="fragment"><div class="line">img=&lt;SOH&gt;u16[height,width] [attributes...]&lt;STX&gt;&lt;image_data&gt;&lt;ETX&gt;</div>
</div><!-- fragment --><p>Where:</p>
<ul>
<li><code>img=</code>: ASCII header indicating the start of an image message.</li>
<li><code>&lt;SOH&gt;</code>: Special byte (0x01, Start of Header) marking the beginning of the metadata section.</li>
<li><code>u16[height,width]</code>: ASCII metadata describing the image type (16-bit unsigned), and its shape.</li>
<li><code>[attributes...]</code>: Optional ASCII key-value pairs for additional metadata (e.g., imageId, timestamp).</li>
<li><code>&lt;STX&gt;</code>: Special byte (0x02, Start of Text) marking the start of the binary image data.</li>
<li><code>&lt;image_data&gt;</code>: Raw image bytes (see below for format and byte order).</li>
<li><code>&lt;ETX&gt;</code>: Special byte (0x03, End of Text) marking the end of the image data.</li>
</ul>
<p>Each message is terminated by a newline (<code>\n</code>) after the <code>&lt;ETX&gt;</code> byte.</p>
<h2>Special Bytes</h2>
<ul>
<li><b>SOH</b> (<code>0x01</code>): Marks the start of the header/metadata section.</li>
<li><b>STX</b> (<code>0x02</code>): Marks the start of the binary image data.</li>
<li><b>ETX</b> (<code>0x03</code>): Marks the end of the binary image data.</li>
</ul>
<p>These bytes are defined in <a class="el" href="../../d5/d31/structirsol_1_1protocol_1_1Serializer_1_1SpecialBytes.html">irsol::protocol::Serializer::SpecialBytes</a>.</p>
<h1>Example</h1>
<p>Suppose the server sends a 2D grayscale image of size 10x16 (height x width), with 16 bits per pixel.</p>
<p>The message sent over the socket will look like (in bytes):</p>
<div class="fragment"><div class="line">69 6d 67 3d 01 75 31 36 5b 31 30 2c 31 36 5d 20 69 6d 61 67 65 49 64 3d 31 20 74 69 6d 65 73 74 61 6d 70 3d 7b 32 30 32 34 2d 30 34 2d 32 35 54 31 32 3a 33 34 3a 35 36 2e 37 38 39 7d 02 ... &lt;image bytes&gt; ... 03 0a</div>
</div><!-- fragment --><p>Breaking this down:</p>
<ul>
<li><code>69 6d 67 3d</code> = "img="</li>
<li><code>01</code> = SOH</li>
<li><code>75 31 36 5b 31 30 2c 31 36 5d</code> = "u16[10,16]"</li>
<li><code>20 69 6d 61 67 65 49 64 3d 31</code> = " imageId=1"</li>
<li><code>20 74 69 6d 65 73 74 61 6d 70 3d 7b ... 7d</code> = " timestamp={...}"</li>
<li><code>02</code> = STX</li>
<li><code>&lt;image bytes&gt;</code> = 10*16*2 = 320 bytes of image data (see below)</li>
<li><code>03</code> = ETX</li>
<li><code>0a</code> = newline</li>
</ul>
<h1>Image Data Format and Byte Order</h1>
<ul>
<li>Each pixel is represented by <b>2 bytes</b> (16 bits).</li>
<li>The server extracts image data from the camera in native order, but <b>before sending, it swaps the two bytes of each pixel</b> (see <a class="el" href="../../dd/d83/structirsol_1_1camera_1_1PixelByteSwapper_3_01true_01_4.html">irsol::camera::PixelByteSwapper&lt;true&gt;()</a> usage in <a class="el" href="../../d1/d6f/classirsol_1_1protocol_1_1Serializer.html#a75edde47044ed71c7a74ed551b4cd144">irsol::protocol::Serializer::serializeImageBinaryData</a>).</li>
<li>This means that for each pixel, if the original bytes are <code>[LSB, MSB]</code>, the server sends <code>[MSB, LSB]</code>.</li>
</ul>
<p><b>Why byte-swapping?</b> <br  />
 This is done to ensure compatibility with existing client-side tools that expect a specific byte order for 16-bit images.</p>
<h1>Client-Side Decoding</h1>
<p>To correctly decode the image, the client must:</p>
<ol type="1">
<li><b>Parse the ASCII header</b> to extract image shape and attributes.</li>
<li><b>Wait for the STX byte</b> to know when the binary image data starts.</li>
<li><b>Read the correct number of bytes</b> (<code>height * width * 2</code>).</li>
<li><b>Optionally Swap the bytes for each pixel</b> to restore the original order, if your application interface needs the 16-bit pixel data in <code>[LSB, MSB]</code>.</li>
<li><b>Convert the buffer to an image matrix</b> (e.g., OpenCV <code>cv::Mat</code>).</li>
</ol>
<h2>Pseudocode for Parsing and Decoding</h2>
<div class="fragment"><div class="line">function receive_image(socket):</div>
<div class="line">    # 1. Read until &#39;img=&#39; header is found</div>
<div class="line">    header = read_until(socket, &#39;=&#39;)</div>
<div class="line">    assert header == &#39;img&#39;</div>
<div class="line"> </div>
<div class="line">    # 2. Wait for SOH (0x01)</div>
<div class="line">    while true:</div>
<div class="line">        byte = read_byte(socket)</div>
<div class="line">        if byte == 0x01:</div>
<div class="line">            break</div>
<div class="line"> </div>
<div class="line">    # 3. Parse metadata (e.g., u16[height,width])</div>
<div class="line">    meta = read_ascii_until(socket, &#39;[&#39;)</div>
<div class="line">    height = parse_int(read_ascii_until(socket, &#39;,&#39;))</div>
<div class="line">    width = parse_int(read_ascii_until(socket, &#39;]&#39;))</div>
<div class="line"> </div>
<div class="line">    # 4. Skip attributes until STX (0x02)</div>
<div class="line">    while true:</div>
<div class="line">        byte = read_byte(socket)</div>
<div class="line">        if byte == 0x02:</div>
<div class="line">            break</div>
<div class="line"> </div>
<div class="line">    # 5. Read image data</div>
<div class="line">    num_bytes = height * width * 2  // 16bit-depth</div>
<div class="line">    image_data = read_exact(socket, num_bytes)</div>
<div class="line"> </div>
<div class="line">    # 6. Wait for ETX (0x03)</div>
<div class="line">    etx = read_byte(socket)</div>
<div class="line">    assert etx == 0x03</div>
<div class="line"> </div>
<div class="line">    # 7. (Optional) Read newline</div>
<div class="line">    read_byte(socket)  # Should be &#39;\n&#39;</div>
<div class="line"> </div>
<div class="line">    # 8. Optionally wap bytes for each pixel if needed in `[LSB, MSB]` form</div>
<div class="line">    for i in 0 .. num_bytes/2 - 1:</div>
<div class="line">        swap(image_data[2*i], image_data[2*i+1])</div>
<div class="line"> </div>
<div class="line">    # 9. Convert to image (e.g., OpenCV)</div>
<div class="line">    image = cv::Mat(height, width, CV_16UC1, image_data)</div>
<div class="line">    # Optionally, rescale from 12-bit to 16-bit if needed, so that the max value of 12-bit representation is mapped to the max value of 16-bit representation</div>
<div class="line"> </div>
<div class="line">    return image</div>
</div><!-- fragment --><h2>Notes</h2>
<ul>
<li>The actual implementation should handle errors and partial reads robustly.</li>
<li>The byte-swapping step is <b>essential</b> for correct image reconstruction, whenever the client-application <b>expects</b> the image byte order for 16-bit-depth pixels to be <code>[LSB, MSB]</code>.</li>
<li>The server may include additional attributes (e.g., imageId, timestamp) in the header, which can be parsed if needed.</li>
</ul>
<h1>Reference: Server Serialization Logic</h1>
<p>See <a class="el" href="../../d1/d6f/classirsol_1_1protocol_1_1Serializer.html">irsol::protocol::Serializer</a>, especially:</p>
<div class="fragment"><div class="line"><span class="comment">// Copy image data to the end of the payload buffer</span></div>
<div class="line"><span class="keywordtype">size_t</span> dataOffset = payload.size();</div>
<div class="line">payload.resize(payload.size() + <a class="code hl_variable" href="../../de/d08/test__parser_8cpp.html#a79750f20a308d13607bec2b6cefa0fc8">msg</a>.data.size());</div>
<div class="line">std::memcpy(&amp;payload[dataOffset], <a class="code hl_variable" href="../../de/d08/test__parser_8cpp.html#a79750f20a308d13607bec2b6cefa0fc8">msg</a>.data.data(), <a class="code hl_variable" href="../../de/d08/test__parser_8cpp.html#a79750f20a308d13607bec2b6cefa0fc8">msg</a>.data.size());</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Swap bytes in-place for 16-bit data (assume always 16-bit)</span></div>
<div class="line"><a class="code hl_struct" href="../../d1/da5/structirsol_1_1camera_1_1PixelByteSwapper.html">irsol::camera::PixelByteSwapper&lt;true&gt;</a>()(</div>
<div class="line">    payload.begin() + <span class="keyword">static_cast&lt;</span>std::ptrdiff_t<span class="keyword">&gt;</span>(dataOffset), payload.end());</div>
<div class="ttc" id="astructirsol_1_1camera_1_1PixelByteSwapper_html"><div class="ttname"><a href="../../d1/da5/structirsol_1_1camera_1_1PixelByteSwapper.html">irsol::camera::PixelByteSwapper</a></div><div class="ttdoc">Utility for swapping pixel bytes in a buffer.</div><div class="ttdef"><b>Definition</b> <a href="../../d2/d8d/pixel__format_8hpp_source.html#l00157">pixel_format.hpp:158</a></div></div>
<div class="ttc" id="atest__parser_8cpp_html_a79750f20a308d13607bec2b6cefa0fc8"><div class="ttname"><a href="../../de/d08/test__parser_8cpp.html#a79750f20a308d13607bec2b6cefa0fc8">msg</a></div><div class="ttdeci">auto msg</div><div class="ttdef"><b>Definition</b> <a href="../../de/d08/test__parser_8cpp_source.html#l00085">test_parser.cpp:85</a></div></div>
</div><!-- fragment --><h1>Reference: Client Parsing Example</h1>
<p>See <a class="el" href="../../d7/da0/viewer__client__gi_8cpp.html">viewer_client_gi.cpp</a> for a real-world implementation. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
